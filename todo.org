#+TITLE: batufo

* Building a 2D Multiplayer Game from Scratch in #Flutter

Hacking on a Multiplayer 2D #Flutter Game with a Node.js backend written in #TypeScript


* Client Side

** Game Cycle

Players already communicate their health to other players which show them as dead.
All that is missing is a regular check client side how many players are still alive.
If only one is alive then we won. (except in single player modus)
If we die we lost.

- [X] detect when game is over either way
- [X] show winner screen if we are last player around
- [X] show looser screen for each player that is killed
- [ ] provide /Back to Menu/ button which allows player to select another level
- [ ] provide /Try Again/ button which restarts player in the same level
- [ ] in both the above cases clean up game specific socket, possible dis->reconnect client entirely
- [ ] recycle game + related socket on server for ended games
- [ ] as a bonus server could detect games from which all clients disconnected and/or haven't gotten any updates in a long time and recycle those regularly

** Exit Game Prematurely

- [ ] provide exit game button

*** Waiting on Players

- [ ] communicate to server that we left and then close socket connection for game
- [ ] server removes player from the client list
- [ ] if no more players remain the game is cleaned up and removed

*** Game Started

- [ ] when a player exits game like this he communicates his health as 0 to the server

*** Disconnected

When we don't hear from a player for a while we need to declare it dead, i.e. send a fake update to all other players with health set to 0.
Otherwise that player becomes invincible as it never reports its health status which the other players rely on to show him as dead.

** Pickups

We wanna add some pickups back in. Most importantly are health packets, but some diamonds to up the score would be nice as well.

- [ ] add health packets to level
- [ ] detect colission with health packets
- [ ] remove health packet on colission
- [ ] up players health after colission
- [ ] add diamonds to level
- [ ] detect colission + remove like with health packets
- [ ] increase score on colission
- [ ] show score animation as was present in single player version


** Dead Game Removal

Even though we could try to detect when a game is over due to a winner we need a more generic solution anyways.
In the case that all players loose interest and disconnect we still need to collect the game eventually.

Therefore a more consistent approach would be to collect any game that didn't get an update from any client for more than 5 secs or so.
Server just runs that check every 5 secs which suffices to weed out dead games.

** DONE Game Stats

- [X] server regularly emits a stats message
- [X] show how many players online in main menu
- [X] show how many players are in games that aren't full, i.e. 3/4 waiting on 1

** DONE Scoring

- [X] player gains score whenever his bullet hits a player
- [X] player gains lots more score if he kills a player
- [X] show score in hud

** DONE Bullet Damage

At this point when a player is hit by a bullet both sides of the game deal out the damage and consider the player killed eventually.
This is not exactly a problem ATM as both sides agree, but is odd.

Instead it should either be the bullet originator who deals out the damage or the player hit by the bullet.

It actually makes sense to increase the bullet originator's score when he hits and kills a player and thus would be more consistent if he also communicates dealt damage.
However we know who the bullet belonged to via the ID, so the player dealt damage to could also communicate that fact including originator ID.
The originator then increases its score.

*** SOLUTION

Inside the [[file:client/lib/controllers/game_controller.dart::void _onPlayerHitByBullet(PlayerModel player) {][GameController]] we deal out health damage only to ourselves.
However when we hit someone else we score. We calculate prospected health and if it is zero we assume that we killed the player and gain appropriately more score.

** DONE Hud

- [X] show hud widget on top of game
- [X] show health in hud
- [X] show how many players left in game in hud
- [X] show time to shoot in hud
- [X] show time to thrust in hud

** DONE Chores

- [X] bullets need to include clientID in the model in order to identify shooter when they hit
- [X] spawned bullet updates no longer need to include clientID
- [X] player updates no longer need to include clientID

** DONE Inputs

- [X] make panning to rotate work
- [X] make tapping to shoot work
- [X] ensure this works on phone

 
** Fixes

*** Bullets Getting Stuck

I've seen that some bullets get stuck at times, i.e. they stick around and stop moving.
So far this is only an issue in the browser, most likely due to the game loop not updating when the browser looses focus.

When a player runs into those he takes damage.

A quick fix could be to just collect all those bullets by checking the ones with velocity zero.

*** [ ] Out of Game Bounds Problem

When game is inactive for a while the ~dt~ is so large that the player position is calculated to be outside of the game boundaries.
Since colission detection is simple it misses that player flew thru the wall.

- fix 1: provide some ray-casting like feature to prevent flying thru walls
- fix 2: detect if player is out of bounds and return him to the nearest in bounds tile

Fix1 is some work but catches flying thru any kind of wall as well.
Fix2 is very simple to implement (in minutes) but would theoretically allow players to jump across walls that are in bounds.

*** DONE Bullet Killing Shooter Problem

Some bullets explode right in front of player when they are shot. Possibly they actually collide with the player itself which will be easier to triage once we have the health in the hud.

It looks like they are and there are two solutions to this.

- A) ignore collisions of bullets with the same ID as the player they collide with
- B) improve bullet initial velocity calculation to take player velocity into account, thus it should be practically impossible for a player to fly into its own bullet

FIXED: by positioning the bullet starting point a bit away from the player.

*** DONE Browser

Currently not working in browser due to socket.io issue. May be fixable if we convert messages we broadcast to strings like we do for the messages that DO work in the browser.

Found reason for things blowing up via the browser is that for some reason the angle that is sent gets packed to be larger than 31-bit, so when we started round tripping the serialization and sending as ~string~ like with the other message we run into problems.

We blow up during ~serialization~. Here are the min/max values I found in the source.
In particular we are above ~jspb.BinaryConstants.TWO_TO_31 = 2147483648~ which causes the crash.

The actual value in one case was ~4294964949~

#+BEGIN_SRC js
jspb.BinaryConstants.FLOAT32_EPS = 1.401298464324817E-45;
jspb.BinaryConstants.FLOAT32_MIN = 1.1754943508222875E-38;
jspb.BinaryConstants.FLOAT32_MAX = 3.4028234663852886E38;
jspb.BinaryConstants.FLOAT64_EPS = 4.9E-324;
jspb.BinaryConstants.FLOAT64_MIN = 2.2250738585072014E-308;
jspb.BinaryConstants.FLOAT64_MAX = 1.7976931348623157E308;
jspb.BinaryConstants.TWO_TO_20 = 1048576;
jspb.BinaryConstants.TWO_TO_23 = 8388608;
jspb.BinaryConstants.TWO_TO_31 = 2147483648;
jspb.BinaryConstants.TWO_TO_32 = 4294967296;
jspb.BinaryConstants.TWO_TO_52 = 4503599627370496;
jspb.BinaryConstants.TWO_TO_63 = 0x7fffffffffffffff;
jspb.BinaryConstants.TWO_TO_64 = 1.8446744073709552E19;
#+END_SRC

- [X] fix1: ensuring that we never send a negative angle
- [X] fix2: ensuring that health is never negative


* WAIT Nice to Have

** WAIT Devices and Fairness

Considering that players on Desktop are at an advantage we could try to match up players by device. Obviously this only works/becomes an issue once we have a certain amount of players online.

** WAIT Visual Cues

- [ ] make any player who is almost dying blink

** WAIT God View

This god view shows all games going on in their own canvas box.
Each canvas would be downsized to show the entire level view.
Most likely this would be a hidden admin feature.

It could help in detecting problems with game recycling.

- [ ] show all games going on by selecting this in main menu
- [ ] server sends all game IDs of active games
- [ ] open view rendering canvas for each game that is active
- [ ] each sub game subscribes to the respective namespace

** WAIT Optimizations

*** [ ] Smoothing Prediction Correction

Right now whenever a player's position is synced that is different from the predicted one we just directly jump to it.
It would be better to smooth this out by adapting the velocity so that eventually prediction and reality converge.

*** [ ] Playability

Multiple tweaks to enhance playability.

- [ ] assuming we show time to shoot in hud experiment with increasing it in order to avoid players just shooting randomly all over the place


* DONE Networking

** DONE Server Relays Player Updates to other Players

 - [X] players need to send updates to server
 - [X] server needs to propagate them
 - [X] figure out why ~Offset~ is always ~Offset.zero~
 - [X] clients need to sync other players accordingly

** DONE Server Relays Spawned Bullest to other Players

 - [X] when player shoots bullet it updates server either as part of player update or separate event
 - [X] server updates all clients with spawned bullet info

** DONE PlayerRequest -> PlayingClient Init [7/7]
:LOGBOOK:
CLOCK: [2020-05-22 Fri 18:35]--[2020-05-22 Fri 19:59] =>  1:24
CLOCK: [2020-05-21 Thu 19:50]--[2020-05-21 Thu 20:20] =>  0:30
CLOCK: [2020-05-21 Thu 18:37]--[2020-05-21 Thu 19:42] =>  1:05
:END:

- [X] send play request to server including desired level
- [X] port tilemap creation from dart to typescript
- [X] port arena creation from dart to typescript in order to build arena on the server
- [X] implement all arena related pack logic
- [X] implement two sample levels
- [X] server reponds with ids + arena
- [X] client prints out arena info

** DONE Init Client from Server Arena
:LOGBOOK:
CLOCK: [2020-05-25 Mon 18:47]--[2020-05-25 Mon 20:03] =>  1:16
:END:

- [X] client connects
- [X] client sends play request
- [X] server responds with playing client including arena
- [X] client renders arena with current player and is in a playable state

*** Resources

- [[https://github.com/carlostse/nodejs-protobuf-socketio][socket.io sample]]
- [[https://github.com/rikulo/socket.io-client-dart][dart socket.io client lib]]
- [[https://github.com/improbable-eng/ts-protoc-gen][ts-protoc-gen]]

** DONE Add Stream based State Management

*** Universe  [6/6]

Manages states and emits them so stream controllers can be used to render appropriate widgets.

- [X] Selecting Level State
- [X] Game Created State (shows waiting for players) includes arena with all players
- [X] Game Started State (subscribes to server updates) includes clientID
- [X] ~Client~ rpc class should have no state
- [X] server needs to send ~ServerInfo~
- [X] server needs to include client index in arena players

** DONE Socket.io Spike [0/0]
:LOGBOOK:
CLOCK: [2020-05-20 Wed 18:41]--[2020-05-20 Wed 19:42] =>  1:01
CLOCK: [2020-05-15 Fri 18:40]--[2020-05-15 Fri 20:17] =>  1:37
CLOCK: [2020-05-14 Thu 18:40]--[2020-05-14 Thu 20:20] =>  1:40
:END:

- [X] setup TS project
- [X] simple socket.io server in TypeScript
- [X] write commandline socket.io dart client
  - [X] [[*Try possible fixes][Try possible fixes]]
- [X] communicate between the two
- [X] find proto lib for JS/TS
- [X] write proto generator script
- [X] communicate proto messages and declare it impossible for now

*** Status

- communicating between server and client, but dart client is unable to deserialize message
- Node.js server + client class have static ~(de)serialize~ methods, but dart classes don't
- also data received is not a ~List~ either
- possibly include a string in the payload to understand data format better

** KILL Using JSON format
:LOGBOOK:
CLOCK: [2020-05-20 Wed 19:51]--[2020-05-20 Wed 20:11] =>  0:20
:END:

No longer necessary since we figured out how to work around the dart socket.io lib treating all incoming messages as JSON.
This allows us to use proto definitions and smaller /albeit not ideal/ payloads (due to the workaround).
  
- [X] ensure this works
- [ ] declare TypeScript payload types only for play request for now
- [ ] determine small format to send, most likely flat arrays
  
  
